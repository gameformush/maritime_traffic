<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maritime Traffic Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f8ff;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #00529B;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        select, button {
            padding: 8px;
            margin: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        button {
            cursor: pointer;
            background: #00529B;
            color: white;
            border: none;
        }
        button:hover {
            background: #003366;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .time-slider {
            flex-grow: 1;
            margin: 0 10px;
        }
        .canvas-container {
            position: relative;
            border: 1px solid #ccc;
            background-color: #e6f7ff;
            margin-bottom: 20px;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        .status-panel {
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            margin-top: 10px;
        }
        .ship-info {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .green {
            background-color: rgba(0, 255, 0, 0.2);
        }
        .yellow {
            background-color: rgba(255, 255, 0, 0.2);
        }
        .red {
            background-color: rgba(255, 0, 0, 0.2);
        }
        .predicted {
            background-color: rgba(150, 150, 150, 0.2);
            border: 1px dashed #999;
        }
        .trajectory {
            stroke-width: 1;
            stroke-dasharray: 3,3;
            fill: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Maritime Traffic Visualization</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="test-case">Test Case:</label>
                <select id="test-case"></select>
            </div>
            
            <div class="control-group">
                <button id="play-pause">Play</button>
                <button id="reset">Reset</button>
            </div>
            
            <div class="control-group">
                <label for="animation-speed">Animation Speed:</label>
                <select id="animation-speed">
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="5">5x</option>
                </select>
            </div>
        </div>
        
        <div class="slider-container">
            <span id="time-label">Time: 0</span>
            <input type="range" min="0" max="100" value="0" class="time-slider" id="time-slider">
            <span id="max-time-label">Max: 0</span>
        </div>
        
        <div class="canvas-container">
            <canvas id="visualization-canvas"></canvas>
        </div>
        
        <div class="status-panel">
            <h3>Ship Status</h3>
            <div id="ship-status"></div>
        </div>
    </div>

    <script>
        // Test case data
        const testCases = {
            "happy_path": {
                name: "Happy Path",
                positions: [
                    {id: "123", time: 123, x: 1, y: 1, status: "green", speed: 0}
                ]
            },
            "two_positions": {
                name: "Two Positions",
                positions: [
                    {id: "123", time: 123, x: 1, y: 1, status: "green", speed: 0},
                    {id: "123", time: 124, x: 2, y: 2, status: "green", speed: 1}
                ]
            },
            "two_ships_standing_still_yellow": {
                name: "Two Ships Standing Still - Yellow",
                positions: [
                    {id: "123", time: 123, x: 1, y: 1, status: "green", speed: 0},
                    {id: "345", time: 124, x: 2, y: 2, status: "yellow", speed: 0}
                ]
            },
            "two_ships_standing_still_red": {
                name: "Two Ships Standing Still - Red",
                positions: [
                    {id: "123", time: 123, x: 1, y: 1, status: "green", speed: 0},
                    {id: "345", time: 124, x: 1, y: 1, status: "red", speed: 0}
                ]
            },
            "two_ships_standing_still_green": {
                name: "Two Ships Standing Still - Green",
                positions: [
                    {id: "123", time: 123, x: 1, y: 1, status: "green", speed: 0},
                    {id: "345", time: 124, x: 3, y: 3, status: "green", speed: 0}
                ]
            },
            "two_ships_parallel_movement": {
                name: "Two Ships Parallel Movement - Green",
                positions: [
                    {id: "123", time: 123, x: 1, y: 0, status: "green", speed: 0},
                    {id: "345", time: 123, x: 0, y: 0, status: "yellow", speed: 0},
                    {id: "123", time: 124, x: 1, y: 1, status: "yellow", speed: 1},
                    {id: "345", time: 124, x: 0, y: 1, status: "yellow", speed: 1}
                ]
            },
            "collision_course_red": {
                name: "Collision Course - Red",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 10, y: 0, status: "green", speed: 0},
                    {id: "123", time: 101, x: 1, y: 0, status: "red", speed: 1},
                    {id: "345", time: 101, x: 9, y: 0, status: "red", speed: 1}
                ]
            },
            "near_miss_yellow": {
                name: "Near Miss - Yellow",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 10, y: 2, status: "green", speed: 0},
                    {id: "123", time: 101, x: 2, y: 0, status: "yellow", speed: 2},
                    {id: "345", time: 101, x: 8, y: 2, status: "yellow", speed: 2}
                ]
            },
            "crossing_paths_different_times": {
                name: "Crossing Paths at Different Times - Green",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 10, y: 10, status: "green", speed: 0},
                    {id: "123", time: 105, x: 5, y: 5, status: "green", speed: 1},
                    {id: "345", time: 105, x: 5, y: 15, status: "green", speed: 1},
                    {id: "345", time: 110, x: 5, y: 5, status: "green", speed: 2}
                ]
            },
            "perpendicular_movement_yellow": {
                name: "Perpendicular Movement - Yellow",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 3, y: 3, status: "green", speed: 0},
                    {id: "123", time: 101, x: 1, y: 0, status: "yellow", speed: 1},
                    {id: "345", time: 101, x: 3, y: 2, status: "yellow", speed: 1}
                ]
            },
            "high_speed_ships_red": {
                name: "High Speed Ships - Red",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 100, y: 0, status: "green", speed: 0},
                    {id: "123", time: 101, x: 20, y: 0, status: "red", speed: 20},
                    {id: "345", time: 101, x: 80, y: 0, status: "red", speed: 20}
                ]
            },
            "ships_pass_yellow_then_green": {
                name: "Ships Pass and Get Further - Yellow then Green",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 4, y: 0, status: "green", speed: 0},
                    {id: "123", time: 101, x: 1, y: 0, status: "yellow", speed: 1},
                    {id: "345", time: 101, x: 3, y: 0, status: "yellow", speed: 1},
                    {id: "123", time: 102, x: 4, y: 0, status: "green", speed: 3},
                    {id: "345", time: 102, x: 0, y: 0, status: "green", speed: 3}
                ]
            },
            "three_ships_collision": {
                name: "Three Ships - Collision Risk",
                positions: [
                    {id: "123", time: 100, x: 0, y: 0, status: "green", speed: 0},
                    {id: "345", time: 100, x: 5, y: 0, status: "green", speed: 0},
                    {id: "678", time: 100, x: 2, y: 2, status: "green", speed: 0},
                    {id: "123", time: 102, x: 2, y: 0, status: "red", speed: 1},
                    {id: "345", time: 102, x: 3, y: 0, status: "red", speed: 1},
                    {id: "678", time: 102, x: 2, y: 0, status: "red", speed: 1}
                ]
            }
        };

        // DOM elements
        const canvas = document.getElementById('visualization-canvas');
        const ctx = canvas.getContext('2d');
        const testCaseSelect = document.getElementById('test-case');
        const timeSlider = document.getElementById('time-slider');
        const timeLabel = document.getElementById('time-label');
        const maxTimeLabel = document.getElementById('max-time-label');
        const playPauseButton = document.getElementById('play-pause');
        const resetButton = document.getElementById('reset');
        const animationSpeedSelect = document.getElementById('animation-speed');
        const shipStatusDiv = document.getElementById('ship-status');

        // State variables
        let currentTestCase = null;
        let currentTime = 0;
        let minTime = 0;
        let maxTime = 0;
        let shipPositionsAtTime = {};
        let isPlaying = false;
        let animationSpeed = 1;
        let animationFrame = null;
        let lastTimestamp = 0;
        let shipColors = {};
        const shipRadius = 5;
        const gridSize = 1; // Changed from 10 to 1 to make each coordinate a single cell
        let scale = 30;
        let offsetX = 50;
        let offsetY = 50;
        
        // Initialize the visualization
        function init() {
            // Populate test case dropdown
            for (const [key, testCase] of Object.entries(testCases)) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = testCase.name;
                testCaseSelect.appendChild(option);
            }
            
            // Set canvas size
            resizeCanvas();
            
            // Event listeners
            testCaseSelect.addEventListener('change', loadTestCase);
            timeSlider.addEventListener('input', handleTimeSliderChange);
            playPauseButton.addEventListener('click', togglePlayPause);
            resetButton.addEventListener('click', resetSimulation);
            animationSpeedSelect.addEventListener('change', updateAnimationSpeed);
            window.addEventListener('resize', resizeCanvas);
            
            // Load first test case
            testCaseSelect.value = Object.keys(testCases)[0];
            loadTestCase();
        }
        
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = 500;
            if (currentTestCase) {
                calculateBoundingBox();
                drawScene();
            }
        }
        
        function loadTestCase() {
            const testCaseKey = testCaseSelect.value;
            currentTestCase = testCases[testCaseKey];
            
            // Determine min and max times
            const times = currentTestCase.positions.map(pos => pos.time);
            minTime = Math.min(...times);
            maxTime = Math.max(...times) + 60; // Add 60 seconds to max time for predictions
            
            // Update time slider
            timeSlider.min = minTime;
            timeSlider.max = maxTime;
            timeSlider.value = minTime;
            maxTimeLabel.textContent = `Max: ${maxTime}`;
            
            // Reset current time
            currentTime = minTime;
            timeLabel.textContent = `Time: ${currentTime}`;
            
            // Stop any ongoing animation
            if (isPlaying) {
                togglePlayPause();
            }
            
            // Assign colors to ships
            assignShipColors();
            
            // Calculate the bounding box for the scene
            calculateBoundingBox();
            
            // Process positions for interpolation
            preprocessPositions();
            
            // Update ship status display
            updateShipStatus();
            
            // Draw the scene
            drawScene();
        }
        
        function assignShipColors() {
            shipColors = {};
            // Get unique ship IDs
            const shipIds = [...new Set(currentTestCase.positions.map(pos => pos.id))];
            
            // Assign a color to each ship
            const baseColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            shipIds.forEach((id, index) => {
                shipColors[id] = baseColors[index % baseColors.length];
            });
        }
        
        function calculateBoundingBox() {
            // Find min and max x,y coordinates
            let minX = Infinity;
            let maxX = -Infinity;
            let minY = Infinity;
            let maxY = -Infinity;
            
            currentTestCase.positions.forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y);
            });
            
            // Add padding
            minX = Math.floor(minX) - 1;
            minY = Math.floor(minY) - 1;
            maxX = Math.ceil(maxX) + 1;
            maxY = Math.ceil(maxY) + 1;
            
            // Set scale to make each grid cell a perfect square
            // A cell size of 1x1 in the data should be mapped to a single grid cell
            const width = maxX - minX;
            const height = maxY - minY;
            const scaleX = (canvas.width - 100) / width;
            const scaleY = (canvas.height - 100) / height;
            scale = Math.min(scaleX, scaleY);
            
            // Calculate offset to center
            offsetX = (canvas.width - (width * scale)) / 2;
            offsetY = (canvas.height - (height * scale)) / 2;
        }
        
        function preprocessPositions() {
            // Group positions by ship ID
            const shipTrajectories = {};
            currentTestCase.positions.forEach(pos => {
                if (!shipTrajectories[pos.id]) {
                    shipTrajectories[pos.id] = [];
                }
                shipTrajectories[pos.id].push(pos);
            });
            
            // Sort positions by time for each ship
            for (const id in shipTrajectories) {
                shipTrajectories[id].sort((a, b) => a.time - b.time);
            }
            
            // Store for later use
            window.shipTrajectories = shipTrajectories;
        }
        
        function getInterpolatedPositions(time) {
            const positions = {};
            const shipTrajectories = window.shipTrajectories;
            
            for (const shipId in shipTrajectories) {
                const trajectory = shipTrajectories[shipId];
                
                // Find positions before and after the given time
                let before = null;
                let after = null;
                
                for (let i = 0; i < trajectory.length; i++) {
                    if (trajectory[i].time <= time) {
                        before = trajectory[i];
                    }
                    if (trajectory[i].time >= time && !after) {
                        after = trajectory[i];
                    }
                }
                
                // If we have both before and after, interpolate
                if (before && after) {
                    if (before.time === after.time) {
                        positions[shipId] = { ...before };
                    } else {
                        const ratio = (time - before.time) / (after.time - before.time);
                        const x = before.x + (after.x - before.x) * ratio;
                        const y = before.y + (after.y - before.y) * ratio;
                        
                        // Interpolate status too
                        let status;
                        if (before.time === time) status = before.status;
                        else if (after.time === time) status = after.status;
                        else status = before.status; // Use earlier status
                        
                        // Calculate speed
                        let speed;
                        if (before.time === time) speed = before.speed;
                        else if (after.time === time) speed = after.speed;
                        else {
                            // Interpolate speed
                            speed = before.speed + (after.speed - before.speed) * ratio;
                        }
                        
                        positions[shipId] = { id: shipId, time, x, y, status, speed };
                    }
                }
                // If we only have before (e.g. for future predictions), extrapolate
                else if (before) {
                    // Get the last recorded position
                    const lastPos = trajectory[trajectory.length - 1];
                    
                    // If the time is beyond the last recorded time, extrapolate
                    if (time > lastPos.time) {
                        // Calculate velocity components from the last position's speed
                        let vx = 0, vy = 0;
                        
                        // If we have at least 2 positions, calculate velocity vector
                        if (trajectory.length >= 2) {
                            const prevPos = trajectory[trajectory.length - 2];
                            const dt = lastPos.time - prevPos.time;
                            
                            // Only calculate if times are different
                            if (dt > 0) {
                                vx = (lastPos.x - prevPos.x) / dt;
                                vy = (lastPos.y - prevPos.y) / dt;
                            }
                        }
                        
                        // Extrapolate position
                        const deltaTime = time - lastPos.time;
                        const x = lastPos.x + vx * deltaTime;
                        const y = lastPos.y + vy * deltaTime;
                        
                        // For future predictions, mark as predicted
                        positions[shipId] = { 
                            id: shipId, 
                            time, 
                            x, 
                            y, 
                            status: lastPos.status, 
                            speed: lastPos.speed,
                            predicted: true 
                        };
                    } else {
                        positions[shipId] = { ...before };
                    }
                }
                // If we only have after, use it 
                else if (after) {
                    positions[shipId] = { ...after };
                }
            }
            
            return positions;
        }
        
        function handleTimeSliderChange() {
            currentTime = parseInt(timeSlider.value);
            timeLabel.textContent = `Time: ${currentTime}`;
            updateShipStatus();
            drawScene();
        }
        
        function togglePlayPause() {
            isPlaying = !isPlaying;
            
            if (isPlaying) {
                playPauseButton.textContent = 'Pause';
                lastTimestamp = performance.now();
                animate();
            } else {
                playPauseButton.textContent = 'Play';
                cancelAnimationFrame(animationFrame);
            }
        }
        
        function resetSimulation() {
            currentTime = minTime;
            timeSlider.value = minTime;
            timeLabel.textContent = `Time: ${currentTime}`;
            
            if (isPlaying) {
                togglePlayPause(); // Stop playback
            }
            
            updateShipStatus();
            drawScene();
        }
        
        function updateAnimationSpeed() {
            animationSpeed = parseFloat(animationSpeedSelect.value);
        }
        
        function animate(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            
            // Advance time based on elapsed time and animation speed
            currentTime += (deltaTime / 1000) * animationSpeed;
            
            if (currentTime >= maxTime) {
                currentTime = maxTime;
                isPlaying = false;
                playPauseButton.textContent = 'Play';
            }
            
            // Update slider
            timeSlider.value = Math.min(Math.max(currentTime, minTime), maxTime);
            timeLabel.textContent = `Time: ${Math.round(currentTime)}`;
            
            // Update ship status and draw scene
            updateShipStatus();
            drawScene();
            
            if (isPlaying) {
                animationFrame = requestAnimationFrame(animate);
            }
        }
        
        function updateShipStatus() {
            shipStatusDiv.innerHTML = '';
            
            const positions = getInterpolatedPositions(currentTime);
            shipPositionsAtTime = positions;
            
            for (const shipId in positions) {
                const ship = positions[shipId];
                const shipDiv = document.createElement('div');
                shipDiv.className = `ship-info ${ship.status}`;
                shipDiv.innerHTML = `
                    <strong>Ship ${ship.id}</strong> - 
                    Position: (${ship.x.toFixed(1)}, ${ship.y.toFixed(1)}), 
                    Speed: ${ship.speed.toFixed(1)}, 
                    Status: ${ship.status.toUpperCase()}
                `;
                shipStatusDiv.appendChild(shipDiv);
            }
        }
        
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawShipTrajectories();
            drawShips();
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;
            
            // Draw vertical grid lines
            for (let x = 0; x <= canvas.width; x += gridSize * scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let y = 0; y <= canvas.height; y += gridSize * scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw coordinates
            ctx.fillStyle = '#333';
            ctx.font = '10px Arial';
            for (let x = 0; x <= canvas.width; x += gridSize * scale) {
                const worldX = Math.round((x - offsetX) / scale);
                ctx.fillText(worldX, x, 10);
            }
            
            for (let y = 0; y <= canvas.height; y += gridSize * scale) {
                const worldY = Math.round((y - offsetY) / scale);
                ctx.fillText(worldY, 5, y);
            }
        }
        
        function drawShipTrajectories() {
            const shipTrajectories = window.shipTrajectories;
            
            for (const shipId in shipTrajectories) {
                const trajectory = shipTrajectories[shipId];
                if (trajectory.length < 2) continue;
                
                ctx.strokeStyle = shipColors[shipId];
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                
                for (let i = 0; i < trajectory.length; i++) {
                    const pos = trajectory[i];
                    const x = offsetX + pos.x * scale;
                    const y = offsetY + pos.y * scale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        function drawShips() {
            for (const shipId in shipPositionsAtTime) {
                const ship = shipPositionsAtTime[shipId];
                const x = offsetX + ship.x * scale;
                const y = offsetY + ship.y * scale;
                
                // Draw ship circle
                ctx.beginPath();
                ctx.arc(x, y, shipRadius, 0, Math.PI * 2);
                
                // Use different style for predicted positions
                if (ship.predicted) {
                    ctx.fillStyle = `${shipColors[shipId]}80`; // Add transparency
                    ctx.strokeStyle = `${getStatusColor(ship.status)}80`; // Add transparency
                    ctx.setLineDash([2, 2]); // Dashed line for predicted positions
                } else {
                    ctx.fillStyle = shipColors[shipId];
                    ctx.strokeStyle = getStatusColor(ship.status);
                    ctx.setLineDash([]); // Solid line for actual positions
                }
                
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash pattern
                
                // Draw ship ID
                ctx.fillStyle = ship.predicted ? '#66666680' : '#000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(ship.id, x, y - shipRadius - 5);
                
                // Draw status indicator
                drawStatusIndicator(x, y + shipRadius + 10, ship.status, ship.predicted);
            }
        }
        
        function drawStatusIndicator(x, y, status, isPredicted) {
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            
            // Use semi-transparent color for predicted positions
            if (isPredicted) {
                ctx.fillStyle = `${getStatusColor(status)}80`; // Add 50% transparency
            } else {
                ctx.fillStyle = getStatusColor(status);
            }
            
            ctx.fill();
        }
        
        function getStatusColor(status) {
            switch (status) {
                case 'green': return '#00cc00';
                case 'yellow': return '#ffcc00';
                case 'red': return '#cc0000';
                default: return '#666666';
            }
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>